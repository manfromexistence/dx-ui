---
title: Philosophy
description: Learn about the philosophy of Kibo UI.
---

Kibo UI is built on a set of core design principles that guide every component and feature. These principles ensure that the library remains flexible, accessible, and developer-friendly as it grows. In this section, we’ll outline Kibo UI’s philosophy and how it influences the design and implementation of the components.

## Composability

Composability is at the heart of Kibo UI. We believe that complex UIs are best built by combining simple, modular pieces. Each Kibo component is designed to do one thing well, and to interoperate with others. This means you can nest components, wrap them, or extend them as needed. For example, the Combobox component can be used on its own, or you could compose it with a form and a list to build a full autocomplete search feature.

Unlike monolithic components that try to handle every scenario (and become unwieldy), Kibo UI favors a “lego block” approach – lots of small pieces that snap together. This philosophy gives developers tremendous flexibility. You’re never stuck with a rigid preset; instead, you can start with Kibo’s building blocks and construct exactly what your application needs.

In practice, composability shows up in the API design: many components are built of sub-components and context. For instance, a complex component like AI Chat might consist of an `AIInput`, `AIMessage`, and `AIResponse` sub-components. You can use the high-level component for convenience, or you can assemble the sub-parts manually if you need custom behavior. This layered design lets advanced users dig deeper, while providing simple defaults for those who want out-of-the-box functionality.

## Simplicity

We strive for simplicity in both usage and implementation. A component should be as straightforward as possible to use – usually a single import and a few understandable props to get started. Under the hood, we try to keep the code lean and clear. Simplicity also means avoiding unnecessary abstractions. If a feature can be implemented with plain React and Tailwind in a few lines, we prefer that over introducing complex configuration or heavy dependencies. This results in components that are easier to maintain and less prone to bugs.

For developers, a simple API means less cognitive load. When you use a Kibo UI component, you won’t need to spend hours reading docs – methods and properties are named clearly, following common conventions. For example, components that act like a form input will use standard props like value, onChange, etc., so they integrate naturally with form state management. By keeping things simple, we also make it easier to customize components. You can often just add Tailwind utility classes or override a small piece of JSX to adjust the look or behavior.

## Accessibility

Accessibility is a non-negotiable aspect of Kibo UI’s design. Every component is built to meet WCAG and ARIA guidelines where applicable. We leverage headless libraries like Radix UI and others specifically because they provide robust accessibility out of the box. Kibo UI components inherit that strength – for example, our dialog (modal) component traps focus and can be navigated with the keyboard by default, our form controls have proper labels and roles, and so on.

We consider not just screen-reader support, but all facets of accessibility: keyboard navigation, color contrast (components use the design tokens which include accessible color palettes), reduced motion preferences, etc. If a component includes an animation (like a carousel or a spinner), we ensure it doesn’t cause problems for users with motion sensitivities. If a component displays text, we ensure the text is readable in both light and dark modes and meets contrast requirements.

By making accessibility a core principle, we aim to save you time – you shouldn’t have to audit basic components for a11y compliance; Kibo UI has done that work for you. Plus, it creates a better experience for all users. Even those without disabilities benefit from keyboard shortcuts, focus indicators, and intuitive UI behaviors.

## Performance

Web performance is crucial. Kibo UI components are built to be lightweight and efficient. Because you only add the components you need (each via the CLI), you avoid the bloat of shipping an entire UI library to the browser. Each component is essentially plain React code, optimized with best practices. We avoid heavy runtime dependencies; many components use either small utility libraries or none at all besides React and Radix primitives.

We also pay attention to how components render and update. For example, components avoid unnecessary re-renders by correctly scoping state or using memoization where appropriate. If a component handles a large list (like a table or list component), it may implement windowing or efficient update patterns to keep the UI snappy. CSS is handled via Tailwind, which means most styling is purely static and atomic – the final CSS delivered to the browser is minimal and optimized by your build tooling (thanks to Tailwind’s JIT compilation and tree-shaking).

Another aspect of performance is not doing work until necessary. Many Kibo UI components are interactive or on-demand. For instance, a Modal or Drop-down might not render its contents until it’s open, reducing the initial load cost. Similarly, heavy logic can be split out (code-split) if needed. The guiding idea: Kibo UI should feel fast – both in terms of development (fast to implement) and in the end-user experience (fast to load and use).

## Developer Experience

DX is extremely important to us. We want using Kibo UI to feel enjoyable. This translates to several concrete things: good documentation, TypeScript support, clear error messages, and sensible defaults.

- **Documentation & Examples**: We provide thorough docs (like this site) with plenty of examples. If a component has any complexity, you’ll find usage examples covering common scenarios. We also highlight edge cases or advanced usage in the docs so you don’t have to guess how to do something uncommon.
- **TypeScript & IntelliSense**: All components are written in TypeScript, so when you import them, you get full autocompletion of props in your IDE. Prop types include comments where needed to explain what they do. If you pass something incorrect, TypeScript will warn you. This reduces the need to constantly refer back to documentation.
- **Defaults & Configuration**: Components come with sensible defaults so that you can drop them in and they work immediately. For example, the Theme Switcher component by default toggles between light and dark using the standard data attribute that shadcn’s system expects. You can customize it, but you don’t have to configure it from scratch. We aim for a “convention over configuration” approach: common use-cases should be frictionless.
- **Error Handling**: When something goes wrong, we try to make it clear. If a component expects a certain context (like a Menu item inside a Menu parent), we may warn if used incorrectly. We also avoid throwing errors unnecessarily – robust components should handle scenarios gracefully (for instance, if you pass null or undefined where an array is expected, we handle it without crashing).

By prioritizing DX, we ensure that you can be highly productive using Kibo UI. The library should get out of your way and let you focus on building your app, not wrestling with the tools.
